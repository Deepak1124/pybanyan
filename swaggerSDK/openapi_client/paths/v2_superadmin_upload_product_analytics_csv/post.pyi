# coding: utf-8

"""


    Generated by: https://openapi-generator.tech
"""

from dataclasses import dataclass
import typing_extensions
import urllib3
from urllib3._collections import HTTPHeaderDict

from openapi_client import api_client, exceptions
from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from openapi_client import schemas  # noqa: F401

# header params
AuthorizationSchema = schemas.StrSchema


class SchemaFor200ResponseBodyTextCsv(
    schemas.DictSchema
):


    class MetaOapg:
        
        class properties:
            OrgID = schemas.StrSchema
            org_name = schemas.StrSchema
            Edition = schemas.StrSchema
            enabled_services = schemas.IntSchema
            num_of_end_users = schemas.IntSchema
            num_of_active_end_users = schemas.IntSchema
            active_end_users__last_30_days = schemas.IntSchema
            active_devices__last_30_days = schemas.IntSchema
            active_end_users__last_90_days = schemas.IntSchema
            active_devices__last_90_days = schemas.IntSchema
            default_connector_state = schemas.StrSchema
            has_user_accessed_last_week = schemas.StrSchema
            admin_users = schemas.StrSchema
            __annotations__ = {
                "OrgID": OrgID,
                "Org name": org_name,
                "Edition": Edition,
                "Enabled services": enabled_services,
                "Num of end users": num_of_end_users,
                "Num of active end users": num_of_active_end_users,
                "Active end users (Last 30 Days)": active_end_users__last_30_days,
                "Active devices (Last 30 Days)": active_devices__last_30_days,
                "Active end users (Last 90 Days)": active_end_users__last_90_days,
                "Active devices (Last 90 Days)": active_devices__last_90_days,
                "Default connector State": default_connector_state,
                "Has User Accessed Last Week?": has_user_accessed_last_week,
                "Admin Users": admin_users,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["OrgID"]) -> MetaOapg.properties.OrgID: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Org name"]) -> MetaOapg.properties.org_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Edition"]) -> MetaOapg.properties.Edition: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Enabled services"]) -> MetaOapg.properties.enabled_services: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Num of end users"]) -> MetaOapg.properties.num_of_end_users: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Num of active end users"]) -> MetaOapg.properties.num_of_active_end_users: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Active end users (Last 30 Days)"]) -> MetaOapg.properties.active_end_users__last_30_days: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Active devices (Last 30 Days)"]) -> MetaOapg.properties.active_devices__last_30_days: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Active end users (Last 90 Days)"]) -> MetaOapg.properties.active_end_users__last_90_days: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Active devices (Last 90 Days)"]) -> MetaOapg.properties.active_devices__last_90_days: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Default connector State"]) -> MetaOapg.properties.default_connector_state: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Has User Accessed Last Week?"]) -> MetaOapg.properties.has_user_accessed_last_week: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["Admin Users"]) -> MetaOapg.properties.admin_users: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["OrgID", "Org name", "Edition", "Enabled services", "Num of end users", "Num of active end users", "Active end users (Last 30 Days)", "Active devices (Last 30 Days)", "Active end users (Last 90 Days)", "Active devices (Last 90 Days)", "Default connector State", "Has User Accessed Last Week?", "Admin Users", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["OrgID"]) -> typing.Union[MetaOapg.properties.OrgID, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Org name"]) -> typing.Union[MetaOapg.properties.org_name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Edition"]) -> typing.Union[MetaOapg.properties.Edition, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Enabled services"]) -> typing.Union[MetaOapg.properties.enabled_services, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Num of end users"]) -> typing.Union[MetaOapg.properties.num_of_end_users, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Num of active end users"]) -> typing.Union[MetaOapg.properties.num_of_active_end_users, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Active end users (Last 30 Days)"]) -> typing.Union[MetaOapg.properties.active_end_users__last_30_days, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Active devices (Last 30 Days)"]) -> typing.Union[MetaOapg.properties.active_devices__last_30_days, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Active end users (Last 90 Days)"]) -> typing.Union[MetaOapg.properties.active_end_users__last_90_days, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Active devices (Last 90 Days)"]) -> typing.Union[MetaOapg.properties.active_devices__last_90_days, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Default connector State"]) -> typing.Union[MetaOapg.properties.default_connector_state, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Has User Accessed Last Week?"]) -> typing.Union[MetaOapg.properties.has_user_accessed_last_week, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["Admin Users"]) -> typing.Union[MetaOapg.properties.admin_users, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["OrgID", "Org name", "Edition", "Enabled services", "Num of end users", "Num of active end users", "Active end users (Last 30 Days)", "Active devices (Last 30 Days)", "Active end users (Last 90 Days)", "Active devices (Last 90 Days)", "Default connector State", "Has User Accessed Last Week?", "Admin Users", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        OrgID: typing.Union[MetaOapg.properties.OrgID, str, schemas.Unset] = schemas.unset,
        Edition: typing.Union[MetaOapg.properties.Edition, str, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'SchemaFor200ResponseBodyTextCsv':
        return super().__new__(
            cls,
            *args,
            OrgID=OrgID,
            Edition=Edition,
            _configuration=_configuration,
            **kwargs,
        )
_all_accept_content_types = (
    'text/csv',
)


class BaseApi(api_client.Api):

    def _v2_superadmin_upload_product_analytics_csv_post_oapg(
        self: api_client.Api,
        header_params: RequestHeaderParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = False,
    ) -> typing.Union[
        ApiResponseFor200,
        api_client.ApiResponseWithoutDeserialization
    ]:
        """
         Generate Product Analytics in CSV Format.
        :param skip_deserialization: If true then api_response.response will be set but
            api_response.body and api_response.headers will not be deserialized into schema
            class instances
        """
        self._verify_typed_dict_inputs_oapg(RequestHeaderParams, header_params)
        used_path = path.value

        _headers = HTTPHeaderDict()
        for parameter in (
            request_header_authorization,
        ):
            parameter_data = header_params.get(parameter.name, schemas.unset)
            if parameter_data is schemas.unset:
                continue
            serialized_data = parameter.serialize(parameter_data)
            _headers.extend(serialized_data)
        # TODO add cookie handling
        if accept_content_types:
            for accept_content_type in accept_content_types:
                _headers.add('Accept', accept_content_type)

        response = self.api_client.call_api(
            resource_path=used_path,
            method='post'.upper(),
            headers=_headers,
            auth_settings=_auth,
            stream=stream,
            timeout=timeout,
        )

        if skip_deserialization:
            api_response = api_client.ApiResponseWithoutDeserialization(response=response)
        else:
            response_for_status = _status_code_to_response.get(str(response.status))
            if response_for_status:
                api_response = response_for_status.deserialize(response, self.api_client.configuration)
            else:
                api_response = api_client.ApiResponseWithoutDeserialization(response=response)

        if not 200 <= response.status <= 299:
            raise exceptions.ApiException(api_response=api_response)

        return api_response


class V2SuperadminUploadProductAnalyticsCsvPost(BaseApi):
    # this class is used by api classes that refer to endpoints with operationId fn names

    def v2_superadmin_upload_product_analytics_csv_post(
        self: BaseApi,
        header_params: RequestHeaderParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = False,
    ) -> typing.Union[
        ApiResponseFor200,
        api_client.ApiResponseWithoutDeserialization
    ]:
        return self._v2_superadmin_upload_product_analytics_csv_post_oapg(
            header_params=header_params,
            accept_content_types=accept_content_types,
            stream=stream,
            timeout=timeout,
            skip_deserialization=skip_deserialization
        )


class ApiForpost(BaseApi):
    # this class is used by api classes that refer to endpoints by path and http method names

    def post(
        self: BaseApi,
        header_params: RequestHeaderParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = False,
    ) -> typing.Union[
        ApiResponseFor200,
        api_client.ApiResponseWithoutDeserialization
    ]:
        return self._v2_superadmin_upload_product_analytics_csv_post_oapg(
            header_params=header_params,
            accept_content_types=accept_content_types,
            stream=stream,
            timeout=timeout,
            skip_deserialization=skip_deserialization
        )


